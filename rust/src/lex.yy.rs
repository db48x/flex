/* A lexical scanner generated by flex */
/* START of m4 controls */
/* M4_YY_TABLES_VERIFY = 0 */
/* M4_YY_REENTRANT */
/* YY_MAIN = 1 */
/* M4_MODE_NO_DO_STDINIT */
/* M4_MODE_NO_YYTEXT_IS_ARRAY */
/* M4_MODE_NO_YYMORE_USED */
/* M4_MODE_NO_REAL_FULLSPD */
/* M4_MODE_NO_REAL_FULLTBL */
/* M4_MODE_NO_CPP_USE_READ */
/* M4_MODE_NO_VARIABLE_TRAILING_CONTEXT_RULES */
/* M4_MODE_FIND_ACTION_REJECT_REALLY_USED */
/* M4_MODE_NO_USES_REJECT */
/* M4_MODE_USEMECS */
/* M4_MODE_FIND_ACTION_COMPRESSED */
/* M4_MODE_NO_FULLSPD */
/* M4_MODE_NO_BOL_NEEDED */
/* M4_MODE_USEECS */
/* M4_MODE_GENTABLES */
/* M4_MODE_INTERACTIVE */
/* M4_MODE_NO_FULLSPD_OR_FULLTBL */
/* M4_MODE_FIND_ACTION_REJECT_OR_INTERACTIVE */
/* M4_MODE_NO_YYWRAP */
/* M4_MODE_INTERACTIVE */
/* M4_MODE_C_ONLY */
/* M4_MODE_PREFIX = yy */
/* END of m4 controls */

extern crate libc;

const FLEX_SCANNER: bool = true;
const MAJOR_VERSION: usize = 2;
const MINOR_VERSION: usize = 6;
const SUBMINOR_VERSION: usize = 4;
const FLEX_BETA: bool = SUBMINOR_VERSION > 0;

type Result<T> = std::result::Result<T, &'static str>;

pub struct Scan<T> {
    /// User-defined. Not touched by flex.
    yyextra_r: T,

    /* The rest are the same as the globals declared in the non-reentrant scanner. */
    yyin_r: libc::FILE,
    yyout_r: libc::FILE,
    /// index of top of stack.
    yy_buffer_stack_top: usize,
    /// capacity of stack.
    yy_buffer_stack_max: usize,
    /// Stack as an array.
    yy_buffer_stack: Option<Vec<BufferState>>,
    yy_hold_char: u8,
    yy_n_chars: usize,
    yyleng_r: usize,
    yy_c_buf_p: usize,
    yy_init: bool,
    yy_start: State,
    yy_did_buffer_switch_on_eof: bool,
    yy_start_stack_ptr: usize,
    yy_start_stack_depth: usize,
    yy_start_stack: Vec<usize>,
    yy_last_accepting_state: State,
    yy_last_accepting_cpos: usize,

    yylineno_r: usize,
    yy_flex_debug_r: usize,

    yytext_r: usize,
    yy_more_flag: usize,
    yy_more_len: usize,
}

impl<T> Scan<T> {
    /** We provide macros for accessing buffer states in case in the
     * future we want to put the buffer states in a more general
     * "scanner state".
     *
     * Returns the top of the stack, or NULL.
     */
    fn current_buffer(&self) -> Option<&BufferState> {
        self.yy_buffer_stack.as_ref().map(|stack| &stack[self.yy_buffer_stack_top])
    }

    fn current_buffer_mut(&mut self) -> Option<&mut BufferState> {
        let top = self.yy_buffer_stack_top;
        self.yy_buffer_stack.as_mut().map(|stack| &mut stack[top])
    }

    /** Same as yy_current_buffer, but useful when we know that the buffer
     * stack is not None. For internal use only.
     */
    fn current_buffer_unchecked(&self) -> &BufferState {
        &self.yy_buffer_stack.as_ref().expect("no buffer stack")[self.yy_buffer_stack_top]
    }

    fn current_buffer_unchecked_mut(&mut self) -> &mut BufferState {
        let top = self.yy_buffer_stack_top;
        &mut self.yy_buffer_stack.as_mut().expect("no buffer stack")[top]
    }
    // #define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]

    fn set_interactive(&mut self, is_interactive: bool) {
        if let None = self.yy_buffer_stack {
            self.ensure_buffer_stack();
            self.push_new_buffer(self.yyin_r, BUF_SIZE);
        }
        if let Some(buf) = self.current_buffer_mut() {
            buf.yy_is_interactive = is_interactive;
        }
    }

    fn set_bol(&mut self, at_bol: bool) {
        if let None = self.yy_buffer_stack {
            self.ensure_buffer_stack();
            self.push_new_buffer(self.yyin_r, BUF_SIZE);
        }
        if let Some(buf) = self.current_buffer_mut() {
            buf.yy_at_bol = at_bol;
        }
    }

    fn ensure_buffer_stack(&mut self) {
    }

    fn at_bol(&self) -> bool {
        match self.current_buffer().map(|buf| buf.yy_at_bol) {
            Some(v) => v,
            None => false,
        }
    }

    /** Done after the current pattern has been matched and before the
      * corresponding action - sets up yytext.
      */
    fn do_before_action(&mut self, yy_bp: usize, yy_cp: usize) {
        self.yytext_r = yy_bp;
        self.yyleng_r = yy_cp - yy_bp;
        self.yy_hold_char = self.current_buffer_unchecked().yy_ch_buf[yy_cp];
        self.current_buffer_unchecked_mut().yy_ch_buf[yy_cp] = '\0' as u8;
        //self.yy_c_buf_p = yy_cp;
    }

// /* Accessor methods to globals.
//    These are made visible to non-reentrant scanners for convenience. */
//
// int yylex_destroy ( yyscan_t yyscanner );
//
// int yyget_debug ( yyscan_t yyscanner );
//
// void yyset_debug ( int debug_flag , yyscan_t yyscanner );
//
// YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );
//
// void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );
//
// FILE *yyget_in ( yyscan_t yyscanner );
//
// void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );
//
// FILE *yyget_out ( yyscan_t yyscanner );
//
// void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );
//
// 			int yyget_leng ( yyscan_t yyscanner );
//
// char *yyget_text ( yyscan_t yyscanner );
//
// int yyget_lineno ( yyscan_t yyscanner );
//
// void yyset_lineno ( int _line_number , yyscan_t yyscanner );
//
// int yyget_column  ( yyscan_t yyscanner );
//
// void yyset_column ( int _column_no , yyscan_t yyscanner );

    /** Gets input and stuffs it into "buf".  Returns number of
      * characters read.
      */
    fn input(&mut self, offset: usize, max_size: usize) -> Result<usize> {
        let file = &mut self.yyin_r.clone(); // file handles are cheap to clone
        let buf = self.current_buffer_unchecked_mut();
        if buf.yy_is_interactive {
            let mut result: usize = 0;
            for n in 0..max_size {
                let c = unsafe { libc::fgetc(file) };
                if c != libc::EOF && c != '\n' as libc::c_int {
                    buf.yy_ch_buf[n+offset] = c as u8
                }
                if c == '\n' as libc::c_int {
                    // TODO(db48x): I think this loop iteration is
                    // supposed to increment n an extra time
                    buf.yy_ch_buf[n+offset+1] = c as u8;
                }
                if c == libc::EOF {
                    let err = unsafe { libc::ferror(file as *mut libc::FILE) };
                    if err != 0 {
                        return Err("input in flex scanner failed");
                    }
                }
                result = n;
            }
            Ok(result as usize)
        } else {
            unsafe { *libc::__errno_location() = 0; }
            let mut result: usize = 0;
            while result == 0 {
                let ptr = buf as *mut _ as *mut libc::c_void;
                result = unsafe { libc::fread(ptr.add(offset), 1, max_size, file) };
                if unsafe { libc::ferror(file) } != libc::EINTR {
                    return Result::Err("input in flex scanner failed");
                }
                unsafe { *libc::__errno_location() = 0; }
                unsafe { libc::clearerr(file); }
            }
            Ok(result)
        }
    }

    /** The main scanner function which does all the work.
     */
    // YY_DECL {
    fn lex<D>(&mut self, _user_data: &mut D) -> Result<()> {
        if !self.yy_init {
            self.yy_init = true;

            // YY_USER_INIT

            if self.yy_start != 0 {
                self.yy_start = 1; // first start state
            }
            self.ensure_buffer_stack();
            self.push_new_buffer(self.yyin_r, BUF_SIZE);

            self.load_buffer_state();
        }

        // open scope of user declarations
        {
            let mut cc: usize = 0;
            let mut wc: usize = 0;
            let mut lc: usize = 0;

            loop { /* loops until end-of-file is reached */
                let mut yy_cp: usize = self.yy_c_buf_p;
                // yy_bp points to the position in yy_ch_buf of the start of the current run.
                let mut yy_bp: usize = yy_cp;

                // Support of yytext.
                self.current_buffer_unchecked_mut().yy_ch_buf[yy_cp] = self.yy_hold_char;

                // Generate the code to find the start state.

                let mut current_state: State = self.yy_start;

                // Set up for storing up states.

                // Generate the code to find the next match.

                'yy_match: loop {
                    loop {
                        let mut c: u8 = yy_ec[yy_cp as usize];
                        // Save the backing-up info \before/ computing the next state because we
                        // always compute one more state than needed - we always proceed until we
                        // reach a jam state

                        // Generate code to keep backing-up information.

                        if yy_accept[current_state as usize] != 0 {
                            self.yy_last_accepting_state = current_state;
                            self.yy_last_accepting_cpos = yy_cp;
                        }

                        while yy_chk[yy_base[current_state as usize] as usize + c as usize] != current_state {
                            current_state = yy_def[current_state as usize];

                            // We've arranged it so that templates are never chained to one another.
                            // This means we can afford to make a very simple test to see if we need
                            // to convert to yy_c's meta-equivalence class without worrying about
                            // erroneously looking up the meta-equivalence class twice

                            // lastdfa + 2 == YY_JAMSTATE + 1 is the beginning of the templates
                            if current_state > JAMSTATE + 1 {
                                c = yy_meta[c as usize];
                            }
                        }

                        current_state = yy_nxt[yy_base[current_state as usize] as usize + c as usize];

                        yy_cp += 1;

                        if yy_base[current_state as usize] == JAMBASE {
                            break;
                        }
                    }

                    'find_action: loop {
                        // code to find the action number goes here

                        let mut yy_act = yy_accept[current_state as usize];
                        if yy_act == 0 {
                            // have to back up
                            yy_cp = self.yy_last_accepting_cpos;
                            current_state = self.yy_last_accepting_state;
                            yy_act = yy_accept[current_state as usize];
                        }

                        // YY_DO_BEFORE_ACTION
                        self.yytext_r = yy_bp;
                        self.yyleng_r = yy_cp - yy_bp;
                        self.yy_hold_char = self.current_buffer_unchecked().yy_ch_buf[yy_cp];
                        self.current_buffer_unchecked_mut().yy_ch_buf[yy_cp] = '\0' as u8;
                        self.yy_c_buf_p = yy_cp;

                        'do_action: loop {
                            match yy_act {
                                0 => { // must back up
                                    // undo the effects of YY_DO_BEFORE_ACTION
                                    self.current_buffer_unchecked_mut().yy_ch_buf[yy_cp] = self.yy_hold_char;

                                    // Backing-up info for compressed tables is taken \after/ yy_cp
                                    // has been incremented for the next state.

                                    yy_cp = self.yy_last_accepting_cpos;

                                    current_state = self.yy_last_accepting_state;
                                    continue 'find_action;
                                },

                                1 => {
                                    // YY_RULE_SETUP
                                    cc += self.yyleng_r;
                                    wc += 1;
                                },

                                2 => {
                                    // YY_RULE_SETUP
                                    cc += self.yyleng_r;
                                },

                                3 => {
                                    // rule 3 can match eol
                                    // YY_RULE_SETUP
                                    lc += 1;
                                    cc += 1;
                                },

                                s if s == END_OF_BUFFER + INITIAL + 1 => {
                                    println!("{:8} {:8} {:8}", lc, wc, cc);
                                    return Ok(());
                                }

                                4 => {
                                    // YY_RULE_SETUP
                                    unsafe {
                                        libc::fwrite(&self.current_buffer_unchecked().yy_ch_buf[self.yytext_r] as *const _ as *const libc::c_void,
                                                     self.yyleng_r,
                                                     1,
                                                     &mut self.yyout_r);
                                    }
                                }

                                s if s == END_OF_BUFFER => {
                                    // Amount of text matched not including the EOB char.
                                    let amount_of_matched_text = yy_cp - self.yytext_r - 1;

                                    // Undo the effects of YY_DO_BEFORE_ACTION.
                                    self.current_buffer_unchecked_mut().yy_ch_buf[yy_cp] = self.yy_hold_char;
                                    // YY_RESTORE_YY_MORE_OFFSET

                                    if self.current_buffer_unchecked().yy_buffer_status == BufferStatus::New {
                                        // We're scanning a new file or input source.  It's possible
                                        // that this happened because the user just pointed yyin at
                                        // a new source and called yylex().  If so, then we have to
                                        // assure consistency between YY_CURRENT_BUFFER and our
                                        // globals.  Here is the right place to do so, because this
                                        // is the first action (other than possibly a back-up) that
                                        // will match for the new input source.
                                        self.yy_n_chars = self.current_buffer_unchecked().yy_n_chars;
                                        self.current_buffer_unchecked_mut().yy_input_file = self.yyin_r;
                                        self.current_buffer_unchecked_mut().yy_buffer_status = BufferStatus::Normal;
                                    }

                                    // Note that here we test for yy_c_buf_p "<=" to the position of
                                    // the first EOB in the buffer, since yy_c_buf_p will already
                                    // have been incremented past the NUL character (since all
                                    // states make transitions on EOB to the end-of-buffer state).
                                    // Contrast this with the test in input().
                                    if self.yy_c_buf_p <= self.yy_n_chars { /* This was really a NUL. */
                                        self.yy_c_buf_p = self.yytext_r + amount_of_matched_text;

                                        current_state = self.get_previous_state();

                                        // Okay, we're now positioned to make the NUL transition.
                                        // we couldn't have yy_get_previous_state() go ahead and do
                                        // it for us because it doesn't know how to deal with the
                                        // possibility of jamming (and we don't want to build
                                        // jamming into it because then it will run more slowly).
                                        let next_state = self.try_NUL_trans(current_state);

                                        yy_bp = self.yytext_r + MORE_ADJ;

                                        if next_state != 0 {
                                            // Consume the NUL
                                            self.yy_c_buf_p += 1;
                                            yy_cp = self.yy_c_buf_p + 1;
                                            current_state = next_state;
                                            continue 'yy_match;
                                        } else {
                                            // Still need to initialize yy_cp, though
                                            // yy_current_state was set up by
                                            // yy_get_previous_state().
                                            yy_cp = self.yy_c_buf_p;
                                            continue 'find_action;
                                        }
                                    } else {
                                        // not a NUL
                                        match self.get_next_buffer()? {
                                            Some(EOBAction::EndOfFile) => {
                                                self.yy_did_buffer_switch_on_eof = false;

                                                if self.wrap() {
                                                    // Note: because we've taken care in
                                                    // yy_get_next_buffer() to have set up yytext,
                                                    // we can now set up yy_c_buf_p so that if some
                                                    // total hoser (like flex itself) wants to call
                                                    // the scanner after we return the YY_NULL,
                                                    // it'll still work - another YY_NULL will get
                                                    // returned.
                                                    self.yy_c_buf_p = self.yytext_r + MORE_ADJ;

                                                    yy_act = END_OF_BUFFER + ((self.yy_start - 1) / 2) + 1;
                                                    continue 'do_action;
                                                } else {
                                                    if !self.yy_did_buffer_switch_on_eof {
                                                        // YY_NEW_FILE;
                                                        self.restart(self.yyin_r);
                                                    }
                                                }
                                            }

                                            Some(EOBAction::ContinueScan) => {
                                                self.yy_c_buf_p = self.yytext_r + amount_of_matched_text;

                                                current_state = self.get_previous_state();

                                                yy_cp = self.yy_c_buf_p;
                                                yy_bp = self.yytext_r + MORE_ADJ;
                                                continue 'yy_match;
                                            }

                                            Some(EOBAction::LastMatch) => {
                                                self.yy_c_buf_p = self.yy_n_chars;

                                                current_state = self.get_previous_state();

                                                yy_cp = self.yy_c_buf_p;
                                                yy_bp = self.yytext_r + MORE_ADJ;
                                                continue 'find_action;
                                            }

                                            None => {
                                                // take no action? get_next_buffer says that it
                                                // wants to "force" the EOB, but it's hard to see
                                                // what that means at the moment.
                                            }
                                        }
                                    }
                                }

                                _ => {
                                    return Err("fatal flex scanner internal error--no action found");
                                }
                            }
                            break;
                        }
                        break;
                    }

                    break 'yy_match;
                }
            }
        }
    }

    fn get_previous_state(&self) -> State {
        unimplemented!();
    }

    fn wrap(&mut self) -> bool {
        unimplemented!();
    }

    fn create_buffer(&mut self, source: libc::FILE, size: usize) -> BufferState {
        unimplemented!();
    }

    fn push_new_buffer(&mut self, source: libc::FILE, size: usize) {
        let buf = self.create_buffer(source, size);
        if let Some(stack) = self.yy_buffer_stack.as_mut() {
            stack.push(buf);
        } else {
            panic!("tried to push to empty stack");
        }
    }

    fn get_next_buffer(&self) -> EOBAction {
        unimplemented!();
    }

    fn load_buffer_state(&mut self) {
        unimplemented!();
    }

    fn try_NUL_trans(&self, current_state: State) -> State {
        unimplemented!();
    }

    fn restart(&mut self, source: libc::FILE) {
        unimplemented!();
    }
}

// /* For convenience, these vars (plus the bison vars far below)
//    are macros in the reentrant scanner. */
// #define yyin yyg->yyin_r
// #define yyout yyg->yyout_r
// #define yyextra yyg->yyextra_r
// #define yyleng yyg->yyleng_r
// #define yytext yyg->yytext_r
// #define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
// #define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
// #define yy_flex_debug yyg->yy_flex_debug_r

// /* Enter a start condition.  This macro really ought to take a parameter,
//  * but we do it the disgusting crufty way forced on us by the ()-less
//  * definition of BEGIN.
//  */
// #define BEGIN yyg->yy_start = 1 + 2 *
// /* Translate the current start state into a value that can be later handed
//  * to BEGIN to return to the state.  The YYSTATE alias is for lex
//  * compatibility.
//  */
// #define YY_START ((yyg->yy_start - 1) / 2)
// #define YYSTATE YY_START
// /* Action number for EOF rule of a given start state. */
// #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
// /* Special action meaning "start processing a new file". */
// #define YY_NEW_FILE yyrestart( yyin , yyscanner )
// #define YY_END_OF_BUFFER_CHAR 0
const END_OF_BUFFER_CHAR: u8 = 0;

/* Size of default input buffer. */
const BUF_SIZE: usize = 32768;
const READ_BUF_SIZE: usize = BUF_SIZE/2;

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
const STATE_BUF_SIZE: usize = (BUF_SIZE + 2) * std::mem::size_of::<State>();

#[derive(PartialEq, Eq)]
enum EndOfBufferAction {
    ContinueScan,
    EndOfFile,
    LastMatch,
}

#[derive(PartialEq, Eq)]
enum EOBAction {
    ContinueScan,
    EndOfFile,
    LastMatch,
}

macro_rules! yy_less_lineno {
    () => {};
}
macro_rules! yy_lineno_rewind_to {
    ( $ptr:expr ) => {};
}

macro_rules! yyless {
    ( $n:literal ) => {
        yy_less_lineno!(n);
        yyg.yy_c_buf_p[yy_cp] = yyg.yy_hold_char;
        yy_restore_yy_more_offset!();
        yy_cp = yy_bp + n - MORE_ADJ;
        yy_do_before_action!();
    };
}

macro_rules! unput {
    ( $c:expr ) => { yyunput(c, yyg.yytext_ptr, yycanner); };
}

#[derive(PartialEq, Eq)]
enum BufferStatus {
    New,
    Normal,
    /** When an EOF's been seen but there's still some text to process
      * then we mark the buffer as YY_EOF_PENDING, to indicate that we
      * shouldn't try reading from the input source any more.  We might
      * still have a bunch of tokens to match, though, because of
      * possible backing-up.
      *
      * When we actually see the EOF, we change the status to "new"
      * (via yyrestart()), so that the user can continue scanning by
      * just pointing yyin at a new input file.
      */
    EOFPending,
}

struct BufferState {
    yy_input_file: libc::FILE,
    /// input buffer
    yy_ch_buf: Vec<u8>,
    /// current position in input buffer
    yy_buf_pos: usize,

    /** Size of input buffer in bytes, not including room for EOB
      * characters.
      */
    yy_buf_size: usize,

    /** Number of characters read into yy_ch_buf, not including EOB
      * characters.
      */
    yy_n_chars: usize,

    /** Whether we "own" the buffer - i.e., we know we created it,
      * and can realloc() it to grow it, and should free() it to
      * delete it.
      */
    yy_is_our_buffer: bool,

    /** Whether this is an "interactive" input source, if so, and
      * if we're using stdio for input, then we want to use getc()
      * instead of fread(), to make sure we stop fetching input after
      * each newline.
      */
    yy_is_interactive: bool,

    /** Whether we're considered to be at the beginning of a line.
      * If so, '^' rules will be active on the next match, otherwise
      * not.
      */
    yy_at_bol: bool,

    /// The line count.
    yy_bs_lineno: usize,
    /// The column count.
    yy_bs_column: usize,

    /** Whether to try to fill the input buffer when we reach the
      * end of it.
      */
    yy_fill_buffer: bool,

    yy_buffer_status: BufferStatus,
}

// /* Begin user sect3 */

fn yywrap<T>(scanner: &Scan<T>) -> usize {
    1
}
const YY_SKIP_YYWRAP: bool = true;

type State = i16;

/* %% [1.5] DFA */
/* START of m4 controls */
/* M4_MODE_NO_NULTRANS */
/* M4_MODE_NO_NULTRANS_FULLTBL */
/* M4_MODE_NO_NULTRANS_FULLSPD */
/* END of m4 controls */

/* START of Flex-generated definitions */
const NUM_RULES: State = 4;
const END_OF_BUFFER: State = 5;
const JAMBASE: State = 7;
const JAMSTATE: State = 9;
const NUL_EC: State = 1;
type Offset = i16;
 /* END of Flex-generated definitions */

struct TransInfo {
    /* We require that yy_verify and yy_nxt must be of the same size int. */

    /* We generate a bogus 'struct yy_trans_info' data type
     * so we can guarantee that it is always declared in the skel.
     * This is so we can compile "sizeof(struct yy_trans_info)"
     * in any scanner.
     */
    yy_verify: i32,
    yy_nxt: i32,
}

/* %% [2.0] data tables for the DFA are inserted here */
const yy_accept: [i16; 10] = [   0,
          0,    0,    5,    1,    2,    3,    1,    2,    0
];

const yy_base: [i16; 12] = [   0,
         0,    0,    6,    0,    0,    7,    0,    0,    7,    4,
         2
];

const yy_def: [i16; 12] = [   0,
         9,    1,    9,   10,   11,    9,   10,   11,    0,    9,
         9
];

const yy_nxt: [i16; 11] = [   0,
         4,    5,    6,    8,    7,    9,    3,    9,    9,    9
];

const yy_chk: [i16; 11] = [   0,
         1,    1,    1,   11,   10,    3,    9,    9,    9,    9
];
/* footprint: 372 bytes */

/* m4 controls begin */
/* M4_MODE_HAS_BACKING_UP */
/* M4_MODE_NEED_YY_CP */
/* m4 controls end */

/* Character equivalence-class mapping */
const yy_ec: [u8; 256] = [ 0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    2,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1
];

/* Character meta-equivalence-class mappings */
const yy_meta: [u8; 4] = [ 0,
         1,    2,    3
];

/** The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
  */
macro_rules! REJECT {
    ( ($whatever:tt)* ) => { panic!("reject used but not detected"); }
}

macro_rules! yymore {
    ( ($whatever:tt)* ) => { panic("yymore used but not detected"); }
}

const MORE_ADJ: usize = 0;
const RESTORE_MORE_OFFSET: bool = false;

/* %% [3.0] static declarations conditional on mode switches go here */
/* First cut at a flex-based "wc" tool. */

const INITIAL: State = 0;

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

// /* No semi-colon after return; correct usage is to write "yyterminate();" -
//  * we don't want an extra ';' after the "return" because that will cause
//  * some compilers to complain about unreachable statements.
//  */
// #ifndef yyterminate
// #define yyterminate() return YY_NULL
// #endif
//
/** Number of entries by which start-condition stack grows. */
const START_STACK_INCR: usize = 25;

/* end tables serialization structures and prototypes */

// /* Code executed at the beginning of each rule, after yytext and yyleng
//  * have been set up.
//  */
// #ifndef YY_USER_ACTION
// #define YY_USER_ACTION
// #endif
//
// /* Code executed at the end of each rule. */
// #ifndef YY_BREAK
// #define YY_BREAK /*LINTED*/break;
// #endif
//
// #define YY_RULE_SETUP \
// 	YY_USER_ACTION

// /* yy_get_next_buffer - try to read in a new buffer
//  *
//  * Returns a code representing an action:
//  *	EOB_ACT_LAST_MATCH -
//  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
//  *	EOB_ACT_END_OF_FILE - end of file
//  */
// static int yy_get_next_buffer (yyscan_t yyscanner)
// {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
// 	char *source = yyg->yytext_ptr;
// 	int number_to_move, i;
// 	int ret_val;
//
// 	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] ) {
// 		YY_FATAL_ERROR( "fatal flex scanner internal error--end of buffer missed" );
// 	}
// 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 ) {
// 		/* Don't try to fill the buffer, so this is an EOF. */
// 		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 ) {
// 			/* We matched a single character, the EOB, so
// 			 * treat this as a final EOF.
// 			 */
// 			return EOB_ACT_END_OF_FILE;
// 		} else {
// 			/* We matched some text prior to the EOB, first
// 			 * process it.
// 			 */
// 			return EOB_ACT_LAST_MATCH;
// 		}
// 	}
//
// 	/* Try to read more data. */
//
// 	/* First move last chars to start of buffer. */
// 	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);
//
// 	for ( i = 0; i < number_to_move; ++i ) {
// 		*(dest++) = *(source++);
// 	}
// 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING ) {
// 		/* don't do the read, it's not guaranteed to return an EOF,
// 		 * just force an EOF
// 		 */
// 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;
// 	} else {
// 		int num_to_read =
// 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
//
// 		while ( num_to_read <= 0 ) { /* Not enough room in the buffer - grow it. */
//
// 			/* just a shorter name for the current buffer */
// 			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
//
// 			int yy_c_buf_p_offset =
// 				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);
//
// 			if ( b->yy_is_our_buffer ) {
// 				int new_size = b->yy_buf_size * 2;
//
// 				if ( new_size <= 0 ) {
// 					b->yy_buf_size += b->yy_buf_size / 8;
// 				} else {
// 					b->yy_buf_size *= 2;
// 				}
// 				b->yy_ch_buf = (char *)
// 					/* Include room in for 2 EOB chars. */
// 					yyrealloc( (void *) b->yy_ch_buf,
// 							 (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
// 			} else {
// 				/* Can't grow it, we don't own it. */
// 				b->yy_ch_buf = NULL;
// 			}
// 			if ( ! b->yy_ch_buf ) {
// 				YY_FATAL_ERROR(
// 				"fatal error - scanner input buffer overflow" );
// 			}
// 			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
//
// 			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
// 						number_to_move - 1;
//
// 		}
//
// 		if ( num_to_read > YY_READ_BUF_SIZE ) {
// 			num_to_read = YY_READ_BUF_SIZE;
// 		}
// 		/* Read in more data. */
// 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
// 			yyg->yy_n_chars, num_to_read );
//
// 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
// 	}
//
// 	if ( yyg->yy_n_chars == 0 ) {
// 		if ( number_to_move == YY_MORE_ADJ ) {
// 			ret_val = EOB_ACT_END_OF_FILE;
// 			yyrestart( yyin  , yyscanner);
// 		} else {
// 			ret_val = EOB_ACT_LAST_MATCH;
// 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
// 				YY_BUFFER_EOF_PENDING;
// 		}
// 	} else {
// 		ret_val = EOB_ACT_CONTINUE_SCAN;
// 	}
// 	if ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
// 		/* Extend the array by 50%, plus the number we really need. */
// 		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
// 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
// 			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );
// 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf ) {
// 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
// 		}
// 		/* "- 2" to take care of EOB's */
// 		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
// 	}
//
// 	yyg->yy_n_chars += number_to_move;
// 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
// 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
//
// 	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
//
// 	return ret_val;
// }
//
// /* yy_get_previous_state - get the state just before the EOB char was reached */
//
// static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
// {
// 	yy_state_type yy_current_state;
// 	char *yy_cp;
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	/* Generate the code to find the start state. */
//
// 			yy_current_state = yyg->yy_start;
//
// 			/* Set up for storing up states. */
//
// 	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp ) {
// 		/* Generate the code to find the next state. */
//
// 	YY_CHAR yy_c = (*yy_cp ? *(yy_ec+YY_SC_TO_UI(*yy_cp)) : YY_NUL_EC);
// 	/* Save the backing-up info \before/ computing the next state
// 	 * because we always compute one more state than needed - we
// 	 * always proceed until we reach a jam state
// 	 */
//
// 		/* Generate code to keep backing-up information. */
//
// 		if ( yy_accept[yy_current_state] )
//
// 			{
// 			yyg->yy_last_accepting_state = yy_current_state;
// 			yyg->yy_last_accepting_cpos = yy_cp;
// 			}
//
// 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
// 		{
// 		yy_current_state = (int) yy_def[yy_current_state];
//
// 		/* We've arranged it so that templates are never chained
// 		 * to one another.  This means we can afford to make a
// 		 * very simple test to see if we need to convert to
// 		 * yy_c's meta-equivalence class without worrying
// 		 * about erroneously looking up the meta-equivalence
// 		 * class twice
// 		 */
//
// 		/* lastdfa + 2 == YY_JAMSTATE + 1 is the beginning of the templates */
// 		if (yy_current_state >= YY_JAMSTATE + 1)
// 			yy_c = yy_meta[yy_c];
//
// 		}
// 	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
//
// 	}
//
// 	return yy_current_state;
// }
//
// /* yy_try_NUL_trans - try to make a transition on the NUL character
//  *
//  * synopsis
//  *	next_state = yy_try_NUL_trans( current_state );
//  */
// static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
// {
// 	int yy_is_jam;
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
// 	/* Generate code for handling NUL's, if needed. */
//
// 	/* First, deal with backing up and setting up yy_cp if the scanner
// 	 * finds that it should JAM on the NUL.
// 	 *
// 	 * Only generate a definition for "yy_cp" if we'll generate code
// 	 * that uses it.  Otherwise lint and the like complain.
// 	 */
// 	char *yy_cp = yyg->yy_c_buf_p;
//
// 	YY_CHAR yy_c = YY_NUL_EC;
// 	/* Save the backing-up info \before/ computing the next state
// 	 * because we always compute one more state than needed - we
// 	 * always proceed until we reach a jam state
// 	 */
//
// 		/* Generate code to keep backing-up information. */
//
// 		if ( yy_accept[yy_current_state] )
//
// 			{
// 			yyg->yy_last_accepting_state = yy_current_state;
// 			yyg->yy_last_accepting_cpos = yy_cp;
// 			}
//
// 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
// 		{
// 		yy_current_state = (int) yy_def[yy_current_state];
//
// 		/* We've arranged it so that templates are never chained
// 		 * to one another.  This means we can afford to make a
// 		 * very simple test to see if we need to convert to
// 		 * yy_c's meta-equivalence class without worrying
// 		 * about erroneously looking up the meta-equivalence
// 		 * class twice
// 		 */
//
// 		/* lastdfa + 2 == YY_JAMSTATE + 1 is the beginning of the templates */
// 		if (yy_current_state >= YY_JAMSTATE + 1)
// 			yy_c = yy_meta[yy_c];
//
// 		}
// 	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
//
// yy_is_jam = (yy_current_state == YY_JAMSTATE);
//
// 	(void)yyg;
// 	return yy_is_jam ? 0 : yy_current_state;
// }
//
// #ifndef YY_NO_UNPUT
//
// static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
// {
// 	char *yy_cp;
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	yy_cp = yyg->yy_c_buf_p;
//
// 	/* undo effects of setting up yytext */
// 	*yy_cp = yyg->yy_hold_char;
//
// 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 ) {
// 		/* need to shift things up to make room */
// 		/* +2 for EOB chars. */
// 		int number_to_move = yyg->yy_n_chars + 2;
// 		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
// 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
// 		char *source =
// 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
//
// 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf ) {
// 			*--dest = *--source;
// 		}
// 		yy_cp += (int) (dest - source);
// 		yy_bp += (int) (dest - source);
// 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
// 			yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
//
// 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 ) {
// 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
// 		}
// 	}
//
// 	*--yy_cp = (char) c;
//
// 	yyg->yytext_ptr = yy_bp;
// 	yyg->yy_hold_char = *yy_cp;
// 	yyg->yy_c_buf_p = yy_cp;
// }
//
// #endif
//
// #ifndef YY_NO_INPUT
// #ifdef __cplusplus
// static int yyinput (yyscan_t yyscanner)
// #else
// static int input  (yyscan_t yyscanner)
// #endif
//
// {
// 	int c;
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	*yyg->yy_c_buf_p = yyg->yy_hold_char;
//
// 	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR ) {
// 		/* yy_c_buf_p now points to the character we want to return.
// 		 * If this occurs *before* the EOB characters, then it's a
// 		 * valid NUL; if not, then we've hit the end of the buffer.
// 		 */
// 		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] ) {
// 			/* This was really a NUL. */
// 			*yyg->yy_c_buf_p = '\0';
// 		} else {
// 			/* need more input */
// 			int offset = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);
// 			++yyg->yy_c_buf_p;
//
// 			switch ( yy_get_next_buffer( yyscanner ) ) {
// 			case EOB_ACT_LAST_MATCH:
// 				/* This happens because yy_g_n_b()
// 				 * sees that we've accumulated a
// 				 * token and flags that we need to
// 				 * try matching the token before
// 				 * proceeding.  But for input(),
// 				 * there's no matching to consider.
// 				 * So convert the EOB_ACT_LAST_MATCH
// 				 * to EOB_ACT_END_OF_FILE.
// 				 */
//
// 				/* Reset buffer status. */
// 				yyrestart( yyin , yyscanner);
//
// 				/*FALLTHROUGH*/
//
// 			case EOB_ACT_END_OF_FILE:
// 				if ( yywrap( yyscanner ) ) {
// 					return 0;
// 				}
// 				if ( ! yyg->yy_did_buffer_switch_on_eof ) {
// 					YY_NEW_FILE;
// 				}
// #ifdef __cplusplus
// 				return yyinput(yyscanner);
// #else
// 				return input(yyscanner);
// #endif
//
// 			case EOB_ACT_CONTINUE_SCAN:
// 				yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
// 				break;
// 			}
// 		}
// 	}
//
// 	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
// 	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
// 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
//
// 	return c;
// }
// #endif	/* ifndef YY_NO_INPUT */
//
// /** Immediately switch to a different input stream.
//  * @param input_file A readable stream.
//  * @param yyscanner The scanner object.
//  * @note This function does not reset the start condition to @c INITIAL .
//  */
// void yyrestart  (FILE * input_file , yyscan_t yyscanner)
// {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	if ( ! YY_CURRENT_BUFFER ) {
// 		yyensure_buffer_stack (yyscanner);
// 		YY_CURRENT_BUFFER_LVALUE =
// 	        	yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
// 	}
//
// 	yy_init_buffer( YY_CURRENT_BUFFER, input_file , yyscanner);
// 	yy_load_buffer_state( yyscanner );
// }
//
// /** Switch to a different input buffer.
//  * @param new_buffer The new input buffer.
//  * @param yyscanner The scanner object.
//  */
// void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
// {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	/* TODO. We should be able to replace this entire function body
// 	 * with
// 	 *		yypop_buffer_state();
// 	 *		yypush_buffer_state(new_buffer);
// 	 */
// 	yyensure_buffer_stack (yyscanner);
// 	if ( YY_CURRENT_BUFFER == new_buffer ) {
// 		return;
// 	}
// 	if ( YY_CURRENT_BUFFER ) {
// 		/* Flush out information for old buffer. */
// 		*yyg->yy_c_buf_p = yyg->yy_hold_char;
// 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
// 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
// 	}
//
// 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
// 	yy_load_buffer_state( yyscanner );
//
// 	/* We don't actually know whether we did this switch during
// 	 * EOF (yywrap()) processing, but the only time this flag
// 	 * is looked at is after yywrap() is called, so it's safe
// 	 * to go ahead and always set it.
// 	 */
// 	yyg->yy_did_buffer_switch_on_eof = 1;
// }
//
// static void yy_load_buffer_state  (yyscan_t yyscanner)
// {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
// 	yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
// 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
// 	yyg->yy_hold_char = *yyg->yy_c_buf_p;
// }
//
// /** Allocate and initialize an input buffer state.
//  * @param file A readable stream.
//  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
//  * @param yyscanner The scanner object.
//  * @return the allocated buffer state.
//  */
// YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
// {
// 	YY_BUFFER_STATE b;
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
// 	if ( ! b ) {
// 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
// 	}
// 	b->yy_buf_size = size;
//
// 	/* yy_ch_buf has to be 2 characters longer than the size given because
// 	 * we need to put in 2 end-of-buffer characters.
// 	 */
// 	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
// 	if ( ! b->yy_ch_buf ) {
// 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
// 	}
// 	b->yy_is_our_buffer = 1;
//
// 	yy_init_buffer( b, file , yyscanner);
//
// 	return b;
// }
//
// /** Destroy the buffer.
//  * @param b a buffer created with yy_create_buffer()
//  * @param yyscanner The scanner object.
//  */
// void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
// {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	if ( ! b ) {
// 		return;
// 	}
// 	if ( b == YY_CURRENT_BUFFER ) {	/* Not sure if we should pop here. */
// 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
// 	}
// 	if ( b->yy_is_our_buffer ) {
// 		yyfree( (void *) b->yy_ch_buf , yyscanner );
// 	}
// 	yyfree( (void *) b , yyscanner );
// }
//
// /* Initializes or reinitializes a buffer.
//  * This function is sometimes called more than once on the same buffer,
//  * such as during a yyrestart() or at EOF.
//  */
// static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)
// {
// 	int oerrno = errno;
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	yy_flush_buffer( b , yyscanner);
//
// 	b->yy_input_file = file;
// 	b->yy_fill_buffer = 1;
//
// 	/* If b is the current buffer, then yy_init_buffer was _probably_
// 	 * called from yyrestart() or through yy_get_next_buffer.
// 	 * In that case, we don't want to reset the lineno or column.
// 	 */
// 	if (b != YY_CURRENT_BUFFER){
// 		b->yy_bs_lineno = 1;
// 		b->yy_bs_column = 0;
// 	}
//
//         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
//
// 	errno = oerrno;
// }
//
// /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
//  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
//  * @param yyscanner The scanner object.
//  */
// void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
// {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	if ( ! b ) {
// 		return;
// 	}
// 	b->yy_n_chars = 0;
//
// 	/* We always need two end-of-buffer characters.  The first causes
// 	 * a transition to the end-of-buffer state.  The second causes
// 	 * a jam in that state.
// 	 */
// 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
// 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
//
// 	b->yy_buf_pos = &b->yy_ch_buf[0];
//
// 	b->yy_at_bol = 1;
// 	b->yy_buffer_status = YY_BUFFER_NEW;
//
// 	if ( b == YY_CURRENT_BUFFER ) {
// 		yy_load_buffer_state( yyscanner );
// 	}
// }
//
// /** Pushes the new state onto the stack. The new state becomes
//  *  the current state. This function will allocate the stack
//  *  if necessary.
//  *  @param new_buffer The new state.
//  *  @param yyscanner The scanner object.
//  */
// void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
// {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	if (new_buffer == NULL) {
// 		return;
// 	}
// 	yyensure_buffer_stack(yyscanner);
//
// 	/* This block is copied from yy_switch_to_buffer. */
// 	if ( YY_CURRENT_BUFFER ) {
// 		/* Flush out information for old buffer. */
// 		*yyg->yy_c_buf_p = yyg->yy_hold_char;
// 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
// 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
// 	}
//
// 	/* Only push if top exists. Otherwise, replace top. */
// 	if (YY_CURRENT_BUFFER) {
// 		yyg->yy_buffer_stack_top++;
// 	}
// 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
//
// 	/* copied from yy_switch_to_buffer. */
// 	yy_load_buffer_state( yyscanner );
// 	yyg->yy_did_buffer_switch_on_eof = 1;
// }
//
// /** Removes and deletes the top of the stack, if present.
//  *  The next element becomes the new top.
//  *  @param yyscanner The scanner object.
//  */
// void yypop_buffer_state (yyscan_t yyscanner)
// {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	if (!YY_CURRENT_BUFFER) {
// 		return;
// 	}
// 	yy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);
// 	YY_CURRENT_BUFFER_LVALUE = NULL;
// 	if (yyg->yy_buffer_stack_top > 0) {
// 		--yyg->yy_buffer_stack_top;
// 	}
// 	if (YY_CURRENT_BUFFER) {
// 		yy_load_buffer_state( yyscanner );
// 		yyg->yy_did_buffer_switch_on_eof = 1;
// 	}
// }
//
// /* Allocates the stack if it does not exist.
//  *  Guarantees space for at least one push.
//  */
// static void yyensure_buffer_stack (yyscan_t yyscanner)
// {
// 	yy_size_t num_to_alloc;
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	if (!yyg->yy_buffer_stack) {
// 		/* First allocation is just for 2 elements, since we don't know if this
// 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
// 		 * immediate realloc on the next call.
// 		 */
// 		num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
// 		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc
// 								(num_to_alloc * sizeof(struct yy_buffer_state*)
// 								, yyscanner);
// 		if ( ! yyg->yy_buffer_stack ) {
// 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
// 		}
//
// 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
//
// 		yyg->yy_buffer_stack_max = num_to_alloc;
// 		yyg->yy_buffer_stack_top = 0;
// 		return;
// 	}
//
// 	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1) {
// 		/* Increase the buffer to prepare for a possible push. */
// 		yy_size_t grow_size = 8 /* arbitrary grow size */;
//
// 		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
// 		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc
// 								(yyg->yy_buffer_stack,
// 								num_to_alloc * sizeof(struct yy_buffer_state*)
// 								, yyscanner);
// 		if ( ! yyg->yy_buffer_stack ) {
// 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
// 		}
// 		/* zero only the new slots.*/
// 		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
// 		yyg->yy_buffer_stack_max = num_to_alloc;
// 	}
// }
//
// /** Setup the input buffer state to scan directly from a user-specified character buffer.
//  * @param base the character buffer
//  * @param size the size in bytes of the character buffer
//  * @param yyscanner The scanner object.
//  * @return the newly allocated buffer state object.
//  */
// YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
// {
// 	YY_BUFFER_STATE b;
//
// 	if ( size < 2 ||
// 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
// 	     base[size-1] != YY_END_OF_BUFFER_CHAR ) {
// 		/* They forgot to leave room for the EOB's. */
// 		return NULL;
// 	}
// 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
// 	if ( ! b ) {
// 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
// 	}
// 	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
// 	b->yy_buf_pos = b->yy_ch_buf = base;
// 	b->yy_is_our_buffer = 0;
// 	b->yy_input_file = NULL;
// 	b->yy_n_chars = b->yy_buf_size;
// 	b->yy_is_interactive = 0;
// 	b->yy_at_bol = 1;
// 	b->yy_fill_buffer = 0;
// 	b->yy_buffer_status = YY_BUFFER_NEW;
//
// 	yy_switch_to_buffer( b , yyscanner );
//
// 	return b;
// }
//
// /** Setup the input buffer state to scan a string. The next call to yylex() will
//  * scan from a @e copy of @a str.
//  * @param yystr a NUL-terminated string to scan
//  * @param yyscanner The scanner object.
//  * @return the newly allocated buffer state object.
//  * @note If you want to scan bytes that may contain NUL values, then use
//  *       yy_scan_bytes() instead.
//  */
// YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)
// {
//
// 	return yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);
// }
//
// /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
//  * scan from a @e copy of @a bytes.
//  * @param yybytes the byte buffer to scan
//  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
//  * @param yyscanner The scanner object.
//  * @return the newly allocated buffer state object.
//  */
// YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner) {
// 	YY_BUFFER_STATE b;
// 	char *buf;
// 	yy_size_t n;
// 	int i;
//
// 	/* Get memory for full buffer, including space for trailing EOB's. */
// 	n = (yy_size_t) (_yybytes_len + 2);
// 	buf = (char *) yyalloc( n , yyscanner );
// 	if ( ! buf ) {
// 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
// 	}
// 	for ( i = 0; i < _yybytes_len; ++i ) {
// 		buf[i] = yybytes[i];
// 	}
// 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
//
// 	b = yy_scan_buffer( buf, n , yyscanner);
// 	if ( ! b ) {
// 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
// 	}
// 	/* It's okay to grow etc. this buffer, and we should throw it
// 	 * away when we're done.
// 	 */
// 	b->yy_is_our_buffer = 1;
//
// 	return b;
// }
//
// #ifndef YY_EXIT_FAILURE
// #define YY_EXIT_FAILURE 2
// #endif
//
// static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	(void)yyg;
// 	fprintf( stderr, "%s\n", msg );
// 	exit( YY_EXIT_FAILURE );
// }
//
// /* Redefine yyless() so it works in section 3 code. */
//
// #undef yyless
// #define yyless(n) \
// 	do { \
// 		/* Undo effects of setting up yytext. */ \
// 		int yyless_macro_arg = (n); \
// 		YY_LESS_LINENO(yyless_macro_arg);\
// 			yytext[yyleng] = yyg->yy_hold_char; \
// 			yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
// 			yyg->yy_hold_char = *yyg->yy_c_buf_p; \
// 			*yyg->yy_c_buf_p = '\0'; \
// 			yyleng = yyless_macro_arg; \
// 	} while ( 0 )
//
// /* Accessor  methods (get/set functions) to struct members. */
//
// /** Get the user-defined data for this scanner.
//  * @param yyscanner The scanner object.
//  */
// YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	return yyextra;
// }
//
// /** Get the current line number.
//  * @param yyscanner The scanner object.
//  */
// int yyget_lineno  (yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	    if (! YY_CURRENT_BUFFER)
// 		return 0;
//
// 	return yylineno;
// }
//
// /** Get the current column number.
//  * @param yyscanner The scanner object.
//  */
// int yyget_column  (yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	if (! YY_CURRENT_BUFFER) {
// 		return 0;
// 	}
//
// 	return yycolumn;
// }
//
// /** Get the input stream.
//  * @param yyscanner The scanner object.
//  */
// FILE *yyget_in  (yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	return yyin;
// }
//
// /** Get the output stream.
//  * @param yyscanner The scanner object.
//  */
// FILE *yyget_out  (yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	return yyout;
// }
//
// /** Get the length of the current token.
//  * @param yyscanner The scanner object.
//  */
// int yyget_leng  (yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	return yyleng;
// }
//
// /** Get the current token.
//  * @param yyscanner The scanner object.
//  */
//
// char *yyget_text  (yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	return yytext;
// }
//
// /** Set the user-defined data. This data is never touched by the scanner.
//  * @param user_defined The data to be associated with this scanner.
//  * @param yyscanner The scanner object.
//  */
// void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	yyextra = user_defined ;
// }
//
// /** Set the current line number.
//  * @param _line_number line number
//  * @param yyscanner The scanner object.
//  */
// void yyset_lineno (int  _line_number , yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	    /* lineno is only valid if an input buffer exists. */
// 		if (! YY_CURRENT_BUFFER ) {
// 			YY_FATAL_ERROR( "yyset_lineno called with no buffer" );
// 		}
//
// 	yylineno = _line_number;
// }
//
// /** Set the current column.
//  * @param _column_no column number
//  * @param yyscanner The scanner object.
//  */
// void yyset_column (int  _column_no , yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	/* column is only valid if an input buffer exists. */
// 	if (! YY_CURRENT_BUFFER ) {
// 	       YY_FATAL_ERROR( "yyset_column called with no buffer" );
// 	}
//
// 	yycolumn = _column_no;
// }
//
// /** Set the input stream. This does not discard the current
//  * input buffer.
//  * @param _in_str A readable stream.
//  * @param yyscanner The scanner object.
//  * @see yy_switch_to_buffer
//  */
// void yyset_in (FILE *  _in_str , yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	yyin = _in_str ;
// }
//
// void yyset_out (FILE *  _out_str , yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	yyout = _out_str ;
// }
//
// int yyget_debug  (yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	return yy_flex_debug;
// }
//
// void yyset_debug (int  _bdebug , yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	yy_flex_debug = _bdebug ;
// }
//
// /* Accessor methods for yylval and yylloc */
//
// /* User-visible API */
//
// /* yylex_init is special because it creates the scanner itself, so it is
//  * the ONLY reentrant function that doesn't take the scanner as the last argument.
//  * That's why we explicitly handle the declaration, instead of using our macros.
//  */
// int yylex_init(yyscan_t* ptr_yy_globals) {
// 	if (ptr_yy_globals == NULL) {
// 		errno = EINVAL;
// 		return 1;
// 	}
//
// 	*ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );
//
// 	if (*ptr_yy_globals == NULL) {
// 		errno = ENOMEM;
// 		return 1;
// 	}
//
// 	/* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
// 	memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
//
// 	return yy_init_globals ( *ptr_yy_globals );
// }
//
// /* yylex_init_extra has the same functionality as yylex_init, but follows the
//  * convention of taking the scanner as the last argument. Note however, that
//  * this is a *pointer* to a scanner, as it will be allocated by this call (and
//  * is the reason, too, why this function also must handle its own declaration).
//  * The user defined value in the first argument will be available to yyalloc in
//  * the yyextra field.
//  */
// int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals ) {
// 	struct yyguts_t dummy_yyguts;
//
// 	yyset_extra (yy_user_defined, &dummy_yyguts);
//
// 	if (ptr_yy_globals == NULL){
// 		errno = EINVAL;
// 		return 1;
// 	}
//
// 	*ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
//
// 	if (*ptr_yy_globals == NULL){
// 		errno = ENOMEM;
// 		return 1;
// 	}
//
// 	/* By setting to 0xAA, we expose bugs in
// 	   yy_init_globals. Leave at 0x00 for releases. */
// 	memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
//
// 	yyset_extra (yy_user_defined, *ptr_yy_globals);
//
// 	return yy_init_globals ( *ptr_yy_globals );
// }
//
// static int yy_init_globals (yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	/* Initialization is the same as for the non-reentrant scanner.
// 	 * This function is called from yylex_destroy(), so don't allocate here.
// 	 */
//
// 	yyg->yy_buffer_stack = NULL;
// 	yyg->yy_buffer_stack_top = 0;
// 	yyg->yy_buffer_stack_max = 0;
// 	yyg->yy_c_buf_p = NULL;
// 	yyg->yy_init = 0;
// 	yyg->yy_start = 0;
//
// 	yyg->yy_start_stack_ptr = 0;
// 	yyg->yy_start_stack_depth = 0;
// 	yyg->yy_start_stack =  NULL;
//
// /* Defined in main.c */
// #ifdef YY_STDINIT
// 	yyin = stdin;
// 	yyout = stdout;
// #else
// 	yyin = NULL;
// 	yyout = NULL;
// #endif
//
// 	/* For future reference: Set errno on error, since we are called by
// 	 * yylex_init()
// 	 */
// 	return 0;
// }
//
// /* yylex_destroy is for both reentrant and non-reentrant scanners. */
// int yylex_destroy  (yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
//
// 	/* Pop the buffer stack, destroying each element. */
// 	while(YY_CURRENT_BUFFER) {
// 		yy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );
// 		YY_CURRENT_BUFFER_LVALUE = NULL;
// 		yypop_buffer_state(yyscanner);
// 	}
//
// 	/* Destroy the stack itself. */
// 	yyfree(yyg->yy_buffer_stack , yyscanner);
// 	yyg->yy_buffer_stack = NULL;
//
// 	/* Destroy the start condition stack. */
//         yyfree( yyg->yy_start_stack , yyscanner );
//         yyg->yy_start_stack = NULL;
//
// 	/* Reset the globals. This is important in a non-reentrant scanner so the next time
// 	 * yylex() is called, initialization will occur. */
// 	yy_init_globals( yyscanner);
//
// 	/* Destroy the main struct (reentrant only). */
// 	yyfree ( yyscanner , yyscanner );
// 	yyscanner = NULL;
// 	return 0;
// }
//
// /*
//  * Internal utility routines.
//  */
//
// #ifndef yytext_ptr
// static void yy_flex_strncpy (char* s1, const char * s2, int n , yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	(void)yyg;
//
// 	int i;
// 	for ( i = 0; i < n; ++i ) {
// 		s1[i] = s2[i];
// 	}
// }
// #endif
//
// #ifdef YY_NEED_STRLEN
// static int yy_flex_strlen (const char * s , yyscan_t yyscanner)
// {
// 	int n;
// 	for ( n = 0; s[n]; ++n )
// 		;
//
// 	return n;
// }
// #endif
//
// void *yyalloc (yy_size_t  size , yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	(void)yyg;
// 	return malloc(size);
// }
//
// void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	(void)yyg;
//
// 	/* The cast to (char *) in the following accommodates both
// 	 * implementations that use char* generic pointers, and those
// 	 * that use void* generic pointers.  It works with the latter
// 	 * because both ANSI C and C++ allow castless assignment from
// 	 * any pointer type to void*, and deal with argument conversions
// 	 * as though doing an assignment.
// 	 */
// 	return realloc(ptr, size);
// }
//
// void yyfree (void * ptr , yyscan_t yyscanner) {
// 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
// 	(void)yyg;
// 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
// }
//
// #line 21 "wc1.l"
