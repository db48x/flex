/* A lexical scanner generated by flex */
/* START of m4 controls */
/* M4_YY_TABLES_VERIFY = 0 */
/* M4_YY_REENTRANT */
/* YY_MAIN = 1 */
/* M4_MODE_NO_DO_STDINIT */
/* M4_MODE_NO_YYTEXT_IS_ARRAY */
/* M4_MODE_NO_YYMORE_USED */
/* M4_MODE_NO_REAL_FULLSPD */
/* M4_MODE_NO_REAL_FULLTBL */
/* M4_MODE_NO_CPP_USE_READ */
/* M4_MODE_NO_VARIABLE_TRAILING_CONTEXT_RULES */
/* M4_MODE_FIND_ACTION_REJECT_REALLY_USED */
/* M4_MODE_NO_USES_REJECT */
/* M4_MODE_USEMECS */
/* M4_MODE_FIND_ACTION_COMPRESSED */
/* M4_MODE_NO_FULLSPD */
/* M4_MODE_NO_BOL_NEEDED */
/* M4_MODE_USEECS */
/* M4_MODE_GENTABLES */
/* M4_MODE_INTERACTIVE */
/* M4_MODE_NO_FULLSPD_OR_FULLTBL */
/* M4_MODE_FIND_ACTION_REJECT_OR_INTERACTIVE */
/* M4_MODE_NO_YYWRAP */
/* M4_MODE_INTERACTIVE */
/* M4_MODE_C_ONLY */
/* M4_MODE_PREFIX = yy */
/* END of m4 controls */

extern crate libc;

const FLEX_SCANNER: bool = true;
const MAJOR_VERSION: usize = 2;
const MINOR_VERSION: usize = 6;
const SUBMINOR_VERSION: usize = 4;
const FLEX_BETA: bool = SUBMINOR_VERSION > 0;

type Result<T> = std::result::Result<T, &'static str>;

#[derive(Default, Debug)]
pub struct Scanner<T> {
    /// User-defined. Not touched by flex.
    yyextra_r: Option<T>,

    /* The rest are the same as the globals declared in the non-reentrant scanner. */
    pub yyin_r: Option<FILE>,
    yyout_r: Option<FILE>,
    /// Stack as an array.
    yy_buffer_stack: Vec<BufferState>,
    yy_hold_char: u8,
    yy_n_chars: usize,
    yyleng_r: usize,
    yy_c_buf_p: usize,
    yy_init: bool,
    yy_start: State,
    yy_did_buffer_switch_on_eof: bool,
    yy_start_stack_ptr: usize,
    yy_start_stack_depth: usize,
    yy_start_stack: Vec<usize>,
    yy_last_accepting_state: State,
    yy_last_accepting_cpos: usize,

    yylineno_r: usize,
    yy_flex_debug_r: usize,

    yytext_r: usize,
    yy_more_flag: usize,
    yy_more_len: usize,
}

impl<T: Default> Scanner<T> {
    pub fn new() -> Self {
        let mut s: Scanner<T> = Default::default();
        s.init(false);
        s
    }
}

impl<T> Scanner<T> {
    fn init(&mut self, stdinit: bool) {
        self.yy_buffer_stack = Vec::new();
        self.yy_c_buf_p = 0;
        self.yy_init = false;
        self.yy_start = 0;

        self.yy_start_stack = Vec::new();
        self.yy_start_stack_depth = 0;

        //if stdinit {
        //    self.yyin_r =
        //    self.yyout_r =
        //}
    }

    /** We provide macros for accessing buffer states in case in the
     * future we want to put the buffer states in a more general
     * "scanner state".
     *
     * Returns the top of the stack, or NULL.
     */
    fn current_buffer(&self) -> Option<&BufferState> {
        self.yy_buffer_stack.last()
    }

    fn current_buffer_mut(&mut self) -> Option<&mut BufferState> {
        self.yy_buffer_stack.last_mut()
    }

    /** Same as yy_current_buffer, but useful when we know that the buffer
     * stack is not None. For internal use only.
     */
    fn current_buffer_unchecked(&self) -> &BufferState {
        self.yy_buffer_stack.last().expect("stack should not be empty")
    }

    fn current_buffer_unchecked_mut(&mut self) -> &mut BufferState {
        self.yy_buffer_stack.last_mut().expect("stack should not be empty")
    }

    fn set_interactive(&mut self, is_interactive: bool) {
        if self.yy_buffer_stack.is_empty() {
            self.push_new_buffer(self.yyin_r, BUF_SIZE);
        }
        if let Some(buf) = self.current_buffer_mut() {
            buf.yy_is_interactive = is_interactive;
        }
    }

    fn set_bol(&mut self, at_bol: bool) {
        if self.yy_buffer_stack.is_empty() {
            self.push_new_buffer(self.yyin_r, BUF_SIZE);
        }
        if let Some(buf) = self.current_buffer_mut() {
            buf.yy_at_bol = at_bol;
        }
    }

    fn at_bol(&self) -> bool {
        match self.current_buffer().map(|buf| buf.yy_at_bol) {
            Some(v) => v,
            None => false,
        }
    }

    /** Done after the current pattern has been matched and before the
      * corresponding action - sets up yytext.
      */
    fn do_before_action(&mut self, yy_bp: usize, yy_cp: usize) {
        self.yytext_r = yy_bp;
        self.yyleng_r = yy_cp - yy_bp;
        self.yy_hold_char = self.current_buffer_unchecked().yy_ch_buf[yy_cp];
        self.current_buffer_unchecked_mut().yy_ch_buf[yy_cp] = b'\0';
        //self.yy_c_buf_p = yy_cp;
    }

    /** Gets input and stuffs it into "buf".  Returns number of
      * characters read.
      */
    fn read(&mut self, offset: usize, max_size: usize) -> Result<usize> {
        if let Some(file) = self.yyin_r {
            let buf = self.current_buffer_unchecked_mut();
            if buf.yy_is_interactive {
                let mut result: usize = 0;
                for n in 0..max_size {
                    let c = unsafe { libc::fgetc(file.0) };
                    if c != libc::EOF && c != '\n' as libc::c_int {
                        buf.yy_ch_buf[n+offset] = c as u8
                    }
                    if c == '\n' as libc::c_int {
                        // TODO(db48x): I think this loop iteration is
                        // supposed to increment n an extra time
                        buf.yy_ch_buf[n+offset+1] = c as u8;
                    }
                    if c == libc::EOF {
                        let err = unsafe { libc::ferror(file.0) };
                        if err != 0 {
                            return Err("input in flex scanner failed");
                        }
                    }
                    result = n;
                }
                Ok(result as usize)
            } else {
                unsafe { *libc::__errno_location() = 0; }
                let mut result: usize = 0;
                while result == 0 {
                    let ptr = buf as *mut _ as *mut libc::c_void;
                    result = unsafe { libc::fread(ptr.add(offset), 1, max_size, file.0) };
                    if unsafe { libc::ferror(file.0) } != libc::EINTR {
                        return Result::Err("input in flex scanner failed");
                    }
                    unsafe { *libc::__errno_location() = 0; }
                    unsafe { libc::clearerr(file.0); }
                }
                Ok(result)
            }
        } else {
            Err("read called with no open input file")
        }
    }

    /** The main scanner function which does all the work.
     */
    // YY_DECL {
    pub fn lex<D>(&mut self, _user_data: &mut D) -> Result<()> {
        if !self.yy_init {
            self.yy_init = true;

            // YY_USER_INIT

            if self.yy_start == 0 {
                self.yy_start = 1; // first start state
            }
            self.push_new_buffer(self.yyin_r, BUF_SIZE);

            self.load_buffer_state();
        }

        // open scope of user declarations
        {
            let mut cc: usize = 0;
            let mut wc: usize = 0;
            let mut lc: usize = 0;

            loop {
                /* loops until end-of-file is reached */
                let mut yy_cp: usize = self.yy_c_buf_p;
                // yy_bp points to the position in yy_ch_buf of the start of the current run.
                let mut yy_bp: usize = yy_cp;

                // Support of yytext.
                self.current_buffer_unchecked_mut().yy_ch_buf[yy_cp] = self.yy_hold_char;

                // Generate the code to find the start state.

                let mut current_state: State = self.yy_start;

                // Set up for storing up states.

                // Generate the code to find the next match.

                'yy_match: loop {
                    loop {
                        let mut c: u8 = yy_ec[yy_cp as usize];
                        // Save the backing-up info \before/ computing the next state because we
                        // always compute one more state than needed - we always proceed until we
                        // reach a jam state

                        // Generate code to keep backing-up information.

                        if yy_accept[current_state as usize] != 0 {
                            self.yy_last_accepting_state = current_state;
                            self.yy_last_accepting_cpos = yy_cp;
                        }

                        while yy_chk[yy_base[current_state as usize] as usize + c as usize] != current_state {
                            current_state = yy_def[current_state as usize];

                            // We've arranged it so that templates are never chained to one another.
                            // This means we can afford to make a very simple test to see if we need
                            // to convert to yy_c's meta-equivalence class without worrying about
                            // erroneously looking up the meta-equivalence class twice

                            // lastdfa + 2 == YY_JAMSTATE + 1 is the beginning of the templates
                            if current_state > JAMSTATE + 1 {
                                c = yy_meta[c as usize];
                            }
                        }

                        current_state = yy_nxt[yy_base[current_state as usize] as usize + c as usize];

                        yy_cp += 1;

                        if yy_base[current_state as usize] == JAMBASE {
                            break;
                        }
                    }

                    'find_action: loop {
                        // code to find the action number goes here

                        let mut yy_act = yy_accept[current_state as usize];
                        if yy_act == 0 {
                            // have to back up
                            yy_cp = self.yy_last_accepting_cpos;
                            current_state = self.yy_last_accepting_state;
                            yy_act = yy_accept[current_state as usize];
                        }

                        // YY_DO_BEFORE_ACTION
                        self.yytext_r = yy_bp;
                        self.yyleng_r = yy_cp - yy_bp;
                        self.yy_hold_char = self.current_buffer_unchecked().yy_ch_buf[yy_cp];
                        self.current_buffer_unchecked_mut().yy_ch_buf[yy_cp] = b'\0';
                        self.yy_c_buf_p = yy_cp;

                        'do_action: loop {
                            match yy_act {
                                0 => { // must back up
                                    // undo the effects of YY_DO_BEFORE_ACTION
                                    self.current_buffer_unchecked_mut().yy_ch_buf[yy_cp] = self.yy_hold_char;

                                    // Backing-up info for compressed tables is taken \after/ yy_cp
                                    // has been incremented for the next state.

                                    yy_cp = self.yy_last_accepting_cpos;

                                    current_state = self.yy_last_accepting_state;
                                    continue 'find_action;
                                },

                                1 => {
                                    // YY_RULE_SETUP
                                    cc += self.yyleng_r;
                                    wc += 1;
                                },

                                2 => {
                                    // YY_RULE_SETUP
                                    cc += self.yyleng_r;
                                },

                                3 => {
                                    // rule 3 can match eol
                                    // YY_RULE_SETUP
                                    lc += 1;
                                    cc += 1;
                                },

                                s if s == END_OF_BUFFER + INITIAL + 1 => {
                                    println!("{:8} {:8} {:8}", lc, wc, cc);
                                    return Ok(());
                                }

                                4 => {
                                    // YY_RULE_SETUP
                                    if let Some(out) = self.yyout_r {
                                        unsafe {
                                            libc::fwrite(&self.current_buffer_unchecked().yy_ch_buf[self.yytext_r] as *const _ as *const libc::c_void,
                                                         self.yyleng_r,
                                                         1,
                                                         out.0);
                                        }
                                    }
                                }

                                s if s == END_OF_BUFFER => {
                                    // Amount of text matched not including the EOB char.
                                    let amount_of_matched_text = yy_cp - self.yytext_r - 1;

                                    // Undo the effects of YY_DO_BEFORE_ACTION.
                                    self.current_buffer_unchecked_mut().yy_ch_buf[yy_cp] = self.yy_hold_char;
                                    // YY_RESTORE_YY_MORE_OFFSET

                                    if self.current_buffer_unchecked().yy_buffer_status == BufferStatus::New {
                                        // We're scanning a new file or input source.  It's possible
                                        // that this happened because the user just pointed yyin at
                                        // a new source and called yylex().  If so, then we have to
                                        // assure consistency between YY_CURRENT_BUFFER and our
                                        // globals.  Here is the right place to do so, because this
                                        // is the first action (other than possibly a back-up) that
                                        // will match for the new input source.
                                        self.yy_n_chars = self.current_buffer_unchecked().yy_n_chars;
                                        self.current_buffer_unchecked_mut().yy_input_file = self.yyin_r;
                                        self.current_buffer_unchecked_mut().yy_buffer_status = BufferStatus::Normal;
                                    }

                                    // Note that here we test for yy_c_buf_p "<=" to the position of
                                    // the first EOB in the buffer, since yy_c_buf_p will already
                                    // have been incremented past the NUL character (since all
                                    // states make transitions on EOB to the end-of-buffer state).
                                    // Contrast this with the test in input().
                                    if self.yy_c_buf_p <= self.yy_n_chars { /* This was really a NUL. */
                                        self.yy_c_buf_p = self.yytext_r + amount_of_matched_text;

                                        current_state = self.get_previous_state();

                                        // Okay, we're now positioned to make the NUL transition.
                                        // we couldn't have yy_get_previous_state() go ahead and do
                                        // it for us because it doesn't know how to deal with the
                                        // possibility of jamming (and we don't want to build
                                        // jamming into it because then it will run more slowly).
                                        let next_state = self.try_NUL_trans(current_state);

                                        yy_bp = self.yytext_r + MORE_ADJ;

                                        if next_state != 0 {
                                            // Consume the NUL
                                            self.yy_c_buf_p += 1;
                                            yy_cp = self.yy_c_buf_p + 1;
                                            current_state = next_state;
                                            continue 'yy_match;
                                        } else {
                                            // Still need to initialize yy_cp, though
                                            // yy_current_state was set up by
                                            // yy_get_previous_state().
                                            yy_cp = self.yy_c_buf_p;
                                            continue 'find_action;
                                        }
                                    } else {
                                        // not a NUL
                                        match self.get_next_buffer()? {
                                            Some(EOBAction::EndOfFile) => {
                                                self.yy_did_buffer_switch_on_eof = false;

                                                if self.wrap() {
                                                    // Note: because we've taken care in
                                                    // yy_get_next_buffer() to have set up yytext,
                                                    // we can now set up yy_c_buf_p so that if some
                                                    // total hoser (like flex itself) wants to call
                                                    // the scanner after we return the YY_NULL,
                                                    // it'll still work - another YY_NULL will get
                                                    // returned.
                                                    self.yy_c_buf_p = self.yytext_r + MORE_ADJ;

                                                    yy_act = END_OF_BUFFER + ((self.yy_start - 1) / 2) + 1;
                                                    continue 'do_action;
                                                } else {
                                                    if !self.yy_did_buffer_switch_on_eof {
                                                        // YY_NEW_FILE;
                                                        self.restart(self.yyin_r);
                                                    }
                                                }
                                            }

                                            Some(EOBAction::ContinueScan) => {
                                                self.yy_c_buf_p = self.yytext_r + amount_of_matched_text;

                                                current_state = self.get_previous_state();

                                                yy_cp = self.yy_c_buf_p;
                                                yy_bp = self.yytext_r + MORE_ADJ;
                                                continue 'yy_match;
                                            }

                                            Some(EOBAction::LastMatch) => {
                                                self.yy_c_buf_p = self.yy_n_chars;

                                                current_state = self.get_previous_state();

                                                yy_cp = self.yy_c_buf_p;
                                                yy_bp = self.yytext_r + MORE_ADJ;
                                                continue 'find_action;
                                            }

                                            None => {
                                                // take no action? get_next_buffer says that it
                                                // wants to "force" the EOB, but it's hard to see
                                                // what that means at the moment.
                                            }
                                        }
                                    }
                                }

                                _ => {
                                    return Err("fatal flex scanner internal error--no action found");
                                }
                            }
                            break;
                        }
                        break;
                    }

                    break 'yy_match;
                }
            }
        }
    }

    /* yy_get_next_buffer - try to read in a new buffer
     *
     * Returns a code representing an action:
     *	EOB_ACT_LAST_MATCH -
     *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
     *	EOB_ACT_END_OF_FILE - end of file
     */
    fn get_next_buffer(&mut self) -> Result<Option<EOBAction>> {
        if self.yy_c_buf_p > self.yy_n_chars + 1 {
            Err("fatal flex scanner internal error--end of buffer missed")
        } else if !self.current_buffer_unchecked().yy_fill_buffer {
            // Don't try to fill the buffer, so this is an EOF.
            if self.yy_c_buf_p - self.yytext_r - MORE_ADJ == 1 {
                // We matched a single character, the EOB, so treat this as a final EOF.
                Ok(Some(EOBAction::EndOfFile))
            } else {
                // We matched some text prior to the EOB, first process it.
                Ok(Some(EOBAction::LastMatch))
            }
        } else {
            // Try to read more data.
            // First move last chars to start of buffer.
            let number_to_move = self.yy_c_buf_p - self.yytext_r - 1;
            let range = self.yytext_r..self.yy_c_buf_p-1;
            self.current_buffer_unchecked_mut().yy_ch_buf.copy_within(range, 0);
            if self.current_buffer_unchecked().yy_buffer_status == BufferStatus::EOFPending {
                // don't do the read, it's not guaranteed to return an EOF, just force an EOF
                self.current_buffer_unchecked_mut().yy_n_chars = 0;
                self.yy_n_chars = 0;
            } else {
                let mut num_to_read = self.current_buffer_unchecked().yy_buf_size - number_to_move - 1;
                if num_to_read > READ_BUF_SIZE {
                    num_to_read = READ_BUF_SIZE;
                }
                // Include room in for 2 EOB chars.
                self.current_buffer_unchecked_mut().yy_ch_buf.reserve(num_to_read + 2);
                let n_chars = self.yy_n_chars;
                self.read(n_chars, num_to_read)?;
                self.current_buffer_unchecked_mut().yy_n_chars = self.yy_n_chars;
                self.yy_n_chars += number_to_move;
            }

            let n_chars = self.yy_n_chars;
            self.current_buffer_unchecked_mut().yy_ch_buf[n_chars] = END_OF_BUFFER_CHAR;
            self.current_buffer_unchecked_mut().yy_ch_buf[n_chars + 1] = END_OF_BUFFER_CHAR;
            self.yytext_r = 0;

            if self.yy_n_chars == 0 {
                if number_to_move == MORE_ADJ {
                    let source = self.yyin_r;
                    self.restart(source);
                    Ok(Some(EOBAction::EndOfFile))
                } else {
                    self.current_buffer_unchecked_mut().yy_buffer_status = BufferStatus::EOFPending;
                    Ok(Some(EOBAction::LastMatch))
                }
            } else {
                Ok(Some(EOBAction::ContinueScan))
            }
        }
    }

    /// get the state just before the EOB char was reached
    fn get_previous_state(&mut self) -> State {
        let mut current_state = self.yy_start;
        // Set up for storing up states.
        for cp in self.yytext_r + MORE_ADJ .. self.yy_c_buf_p {
            // Generate the code to find the next state.
            let mut c: u8 = if self.current_buffer_unchecked().yy_ch_buf[cp] == 0 {
                NUL_EC
            } else {
                yy_ec[self.current_buffer_unchecked().yy_ch_buf[cp as usize] as usize]
            };

            // Save the backing-up info \before/ computing the next state because we always compute
            // one more state than needed - we always proceed until we reach a jam state

            // Generate code to keep backing-up information.

            if yy_accept[current_state as usize] != 0 {
                self.yy_last_accepting_state = current_state;
                self.yy_last_accepting_cpos = cp;
            }

            while yy_chk[yy_base[current_state as usize] as usize + c as usize] != current_state {
                current_state = yy_def[current_state as usize];

                // We've arranged it so that templates are never chained to one another.  This means
                // we can afford to make a very simple test to see if we need to convert to yy_c's
                // meta-equivalence class without worrying about erroneously looking up the
                // meta-equivalence class twice.

                // lastdfa + 2 == YY_JAMSTATE + 1 is the beginning of the templates
                if current_state > JAMSTATE + 1 {
                    c = yy_meta[c as usize];
                }
            }
            current_state = yy_nxt[yy_base[current_state as usize] as usize + c as usize];
        }
        current_state
    }

    /// try to make a transition on the NUL character
    ///
    /// synopsis
    ///   next_state = yy_try_NUL_trans( current_state );
    fn try_NUL_trans(&mut self, current_state: State) -> State {
        let mut current_state = current_state;
        // Generate code for handling NUL's, if needed.

        // First, deal with backing up and setting up yy_cp if the scanner finds that it should JAM
        // on the NUL.
        //
        // Only generate a definition for "yy_cp" if we'll generate code that uses it.  Otherwise
        // lint and the like complain.
        let cp = self.yy_c_buf_p;

        let mut c = NUL_EC;
        // Save the backing-up info \before/ computing the next state because we always compute one
        // more state than needed - we always proceed until we reach a jam state

        // Generate code to keep backing-up information.

        if yy_accept[current_state as usize] != 0 {
            self.yy_last_accepting_state = current_state;
            self.yy_last_accepting_cpos = cp;
        }
        while yy_chk[yy_base[current_state as usize] as usize + c as usize] != current_state {
            current_state = yy_def[current_state as usize];

            // We've arranged it so that templates are never chained to one another.  This means we
            // can afford to make a very simple test to see if we need to convert to yy_c's
            // meta-equivalence class without worrying about erroneously looking up the
            // meta-equivalence class twice

            // lastdfa + 2 == YY_JAMSTATE + 1 is the beginning of the templates
            if current_state > JAMSTATE {
                c = yy_meta[c as usize];
            }
        }
        current_state = yy_nxt[yy_base[current_state as usize] as usize + c as usize];
        let is_jam = current_state == JAMSTATE;
        if is_jam { 0 } else { current_state }
    }

    fn unput(&mut self, c: u8, bp: usize) {
        let mut cp = self.yy_c_buf_p;
        // undo effects of setting up yytext
        self.current_buffer_unchecked_mut().yy_ch_buf[cp] = self.yy_hold_char;
        // TODO(db48x): this code originally said "need to shift things up to make room +2 for EOB
        // chars."; might need to put that back in.
        if cp == 0 {
            self.current_buffer_unchecked_mut().yy_ch_buf.insert(0, c);
        } else {
            cp -= 1;
            self.current_buffer_unchecked_mut().yy_ch_buf[cp] = c;
        }
        self.yytext_r = bp;
        self.yy_hold_char = self.current_buffer_unchecked().yy_ch_buf[cp];
        self.yy_c_buf_p = cp;
    }

    fn input(&mut self) -> Result<u8> {
        let p = self.yy_c_buf_p;
        self.current_buffer_unchecked_mut().yy_ch_buf[p] = self.yy_hold_char;

        if self.current_buffer_unchecked().yy_ch_buf[self.yy_c_buf_p] == END_OF_BUFFER_CHAR {
            // yy_c_buf_p now points to the character we want to return.  If this occurs *before*
            // the EOB characters, then it's a valid NUL; if not, then we've hit the end of the
            // buffer.
            if self.yy_c_buf_p < self.yy_n_chars {
                // This was really a NUL.
                let p = self.yy_c_buf_p;
                self.current_buffer_unchecked_mut().yy_ch_buf[p] = b'\0';
            } else {
                // need more input
                let offset = self.yy_c_buf_p - self.yytext_r;
                self.yy_c_buf_p += 1;

                match self.get_next_buffer()? {
                    Some(EOBAction::LastMatch) => {
                        // This happens because yy_g_n_b() sees that we've accumulated a token and
                        // flags that we need to try matching the token before proceeding.  But for
                        // input(), there's no matching to consider.  So convert the
                        // EOB_ACT_LAST_MATCH to EOB_ACT_END_OF_FILE.

                        // Reset buffer status.
                        self.restart(self.yyin_r);

                        if self.wrap() {
                            return Ok(b'\0');
                        }
                        if !self.yy_did_buffer_switch_on_eof {
                            // YY_NEW_FILE
                            self.restart(self.yyin_r);
                        }
                        return self.input();
                    }

                    Some(EOBAction::EndOfFile) => {
                        if self.wrap() {
                            return Ok(b'\0');
                        }
                        if !self.yy_did_buffer_switch_on_eof {
                            // YY_NEW_FILE
                            self.restart(self.yyin_r);
                        }
                        return self.input();
                    }

                    Some(EOBAction::ContinueScan) => {
                        self.yy_c_buf_p = self.yytext_r + offset;
                    }

                    None => { unreachable!(); }
                }
            }
        }

        let c = self.current_buffer_unchecked().yy_ch_buf[self.yy_c_buf_p];
        let p = self.yy_c_buf_p;
        self.current_buffer_unchecked_mut().yy_ch_buf[p] = b'\0';
        self.yy_c_buf_p += 1;
        self.yy_hold_char = self.current_buffer_unchecked().yy_ch_buf[self.yy_c_buf_p];
        Ok(c)
    }

    /// Immediately switch to a different input stream.  This function does not reset the start condition
    /// to @c INITIAL .
    fn restart(&mut self, source: Option<FILE>) {
        if self.current_buffer().is_none() {
            self.push_new_buffer(self.yyin_r, BUF_SIZE);
        }
        self.current_buffer_unchecked_mut().init(source);
        // If b is the current buffer, then yy_init_buffer was _probably_ called from yyrestart() or
        // through yy_get_next_buffer.  In that case, we don't want to reset the lineno or column.
        self.current_buffer_unchecked_mut().yy_bs_lineno = 1;
        self.current_buffer_unchecked_mut().yy_bs_column = 0;
        self.load_buffer_state();
    }

    /// Switch to a different input buffer.
    fn switch_to_buffer(&mut self, new_buffer: BufferState) {
        // TODO. We should be able to replace this entire function body with
        //      yypop_buffer_state();
        //      yypush_buffer_state(new_buffer);
        if *self.current_buffer_unchecked() != new_buffer {
            if self.current_buffer().is_some() {
                // Flush out information for old buffer.
                let p = self.yy_c_buf_p;
                self.current_buffer_unchecked_mut().yy_ch_buf[p] = self.yy_hold_char;
                self.current_buffer_unchecked_mut().yy_buf_pos = self.yy_c_buf_p;
                self.current_buffer_unchecked_mut().yy_n_chars = self.yy_n_chars;
            }
            *self.current_buffer_unchecked_mut() = new_buffer;
            self.load_buffer_state();

            // We don't actually know whether we did this switch during EOF (yywrap()) processing,
            // but the only time this flag is looked at is after yywrap() is called, so it's safe to
            // go ahead and always set it.
            self.yy_did_buffer_switch_on_eof = true;
        }
    }

    fn load_buffer_state(&mut self) {
        self.yy_n_chars = self.current_buffer_unchecked().yy_n_chars;
        self.yytext_r = self.current_buffer_unchecked().yy_buf_pos;
        self.yy_c_buf_p = self.current_buffer_unchecked().yy_buf_pos;
        self.yyin_r = self.current_buffer_unchecked().yy_input_file;
        self.yy_hold_char = self.current_buffer_unchecked().yy_ch_buf[self.yy_c_buf_p];
    }

    fn push_new_buffer(&mut self, source: Option<FILE>, size: usize) {
        let buf = BufferState::new(source, size);
        self.push_buffer_state(buf)
    }

    /// Pushes the new state onto the stack. The new state becomes the current state. This function will
    /// allocate the stack if necessary.
    fn push_buffer_state(&mut self, new_buffer: BufferState) {
        if self.current_buffer().is_some() {
            // Flush out information for old buffer.
            let p = self.yy_c_buf_p;
            self.current_buffer_unchecked_mut().yy_ch_buf[p] = self.yy_hold_char;
            self.current_buffer_unchecked_mut().yy_buf_pos = self.yy_c_buf_p;
            self.current_buffer_unchecked_mut().yy_n_chars = self.yy_n_chars;
        }

        self.yy_buffer_stack.push(new_buffer);
        // copied from yy_switch_to_buffer.
        self.load_buffer_state();
        self.yy_did_buffer_switch_on_eof = true;
    }

    // Removes and deletes the top of the stack, if present.  The next element becomes the new top.
    fn pop_buffer_state(&mut self) {
        self.yy_buffer_stack.pop();
        if !self.yy_buffer_stack.is_empty() {
            self.load_buffer_state();
            self.yy_did_buffer_switch_on_eof = true;
        }
    }

    fn wrap(&mut self) -> bool {
        true
    }
}

const END_OF_BUFFER_CHAR: u8 = 0;

/* Size of default input buffer. */
const BUF_SIZE: usize = 32768;
const READ_BUF_SIZE: usize = BUF_SIZE/2;

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
const STATE_BUF_SIZE: usize = (BUF_SIZE + 2) * std::mem::size_of::<State>();

#[derive(PartialEq, Eq)]
enum EndOfBufferAction {
    ContinueScan,
    EndOfFile,
    LastMatch,
}

#[derive(PartialEq, Eq)]
enum EOBAction {
    ContinueScan,
    EndOfFile,
    LastMatch,
}

macro_rules! yy_less_lineno {
    () => {};
}
macro_rules! yy_lineno_rewind_to {
    ( $ptr:expr ) => {};
}

macro_rules! yyless {
    ( $n:literal ) => {
        yy_less_lineno!(n);
        yyg.yy_c_buf_p[yy_cp] = yyg.yy_hold_char;
        yy_restore_yy_more_offset!();
        yy_cp = yy_bp + n - MORE_ADJ;
        yy_do_before_action!();
    };
}

macro_rules! unput {
    ( $c:expr ) => { yyunput(c, yyg.yytext_ptr, yycanner); };
}

#[derive(Debug, PartialEq, Eq)]
enum BufferStatus {
    New,
    Normal,
    /** When an EOF's been seen but there's still some text to process
      * then we mark the buffer as YY_EOF_PENDING, to indicate that we
      * shouldn't try reading from the input source any more.  We might
      * still have a bunch of tokens to match, though, because of
      * possible backing-up.
      *
      * When we actually see the EOF, we change the status to "new"
      * (via yyrestart()), so that the user can continue scanning by
      * just pointing yyin at a new input file.
      */
    EOFPending,
}

#[derive(Debug, PartialEq, Eq)]
struct BufferState {
    yy_input_file: Option<FILE>,
    /// input buffer
    yy_ch_buf: Vec<u8>,
    /// current position in input buffer
    yy_buf_pos: usize,

    /** Size of input buffer in bytes, not including room for EOB
      * characters.
      */
    yy_buf_size: usize,

    /** Number of characters read into yy_ch_buf, not including EOB
      * characters.
      */
    yy_n_chars: usize,

    /** Whether we "own" the buffer - i.e., we know we created it,
      * and can realloc() it to grow it, and should free() it to
      * delete it.
      */
    yy_is_our_buffer: bool,

    /** Whether this is an "interactive" input source, if so, and
      * if we're using stdio for input, then we want to use getc()
      * instead of fread(), to make sure we stop fetching input after
      * each newline.
      */
    yy_is_interactive: bool,

    /** Whether we're considered to be at the beginning of a line.
      * If so, '^' rules will be active on the next match, otherwise
      * not.
      */
    yy_at_bol: bool,

    /// The line count.
    yy_bs_lineno: usize,
    /// The column count.
    yy_bs_column: usize,

    /** Whether to try to fill the input buffer when we reach the
      * end of it.
      */
    yy_fill_buffer: bool,

    yy_buffer_status: BufferStatus,
}

impl BufferState {
    /// Allocate and initialize an input buffer state.
    fn new(source: Option<FILE>, size: usize) -> BufferState {
        let mut b = BufferState {
            yy_input_file: source,
            yy_ch_buf: Vec::with_capacity(size + 2),
            yy_buf_pos: 0,
            yy_buf_size: size + 2,
            yy_n_chars: 0,
            yy_is_our_buffer: true,
            yy_is_interactive: false,
            yy_at_bol: false,
            yy_bs_lineno: 1,
            yy_bs_column: 0,
            yy_fill_buffer: false,
            yy_buffer_status: BufferStatus::New
        };
        b.init(source);
        b
    }


    // Initializes or reinitializes a buffer.  This function is sometimes called more than once on
    // the same buffer, such as during a yyrestart() or at EOF.
    fn init(&mut self, source: Option<FILE>) {
        let oerrno = unsafe { *libc::__errno_location() };
        self.flush();

        self.yy_input_file = source;
        self.yy_fill_buffer = true;
        self.yy_is_interactive = if let Some(file) = source {
            unsafe { libc::isatty(libc::fileno(&file.0 as *const _ as *mut libc::FILE)) > 0 }
        } else {
            false
        };
        unsafe { *libc::__errno_location() = oerrno; }
    }

    /// Discard all buffered characters. On the next scan, YY_INPUT will be called.
    fn flush(&mut self) {
        self.yy_n_chars = 0;

        // We always need two end-of-buffer characters.  The first causes a transition to the
        // end-of-buffer state.  The second causes a jam in that state.
        self.yy_ch_buf[0] = END_OF_BUFFER_CHAR;
        self.yy_ch_buf[1] = END_OF_BUFFER_CHAR;

        self.yy_buf_pos = 0;

        self.yy_at_bol = true;
        self.yy_buffer_status = BufferStatus::New;
    }
}

// /* Begin user sect3 */

type State = i16;

/* %% [1.5] DFA */
/* START of m4 controls */
/* M4_MODE_NO_NULTRANS */
/* M4_MODE_NO_NULTRANS_FULLTBL */
/* M4_MODE_NO_NULTRANS_FULLSPD */
/* END of m4 controls */

/* START of Flex-generated definitions */
const NUM_RULES: State = 4;
const END_OF_BUFFER: State = 5;
const JAMBASE: State = 7;
const JAMSTATE: State = 9;
const NUL_EC: u8 = 1;
type Offset = i16;
 /* END of Flex-generated definitions */

struct TransInfo {
    /* We require that yy_verify and yy_nxt must be of the same size int. */

    /* We generate a bogus 'struct yy_trans_info' data type
     * so we can guarantee that it is always declared in the skel.
     * This is so we can compile "sizeof(struct yy_trans_info)"
     * in any scanner.
     */
    yy_verify: i32,
    yy_nxt: i32,
}

/* %% [2.0] data tables for the DFA are inserted here */
const yy_accept: [i16; 10] = [   0,
          0,    0,    5,    1,    2,    3,    1,    2,    0
];

const yy_base: [i16; 12] = [   0,
         0,    0,    6,    0,    0,    7,    0,    0,    7,    4,
         2
];

const yy_def: [i16; 12] = [   0,
         9,    1,    9,   10,   11,    9,   10,   11,    0,    9,
         9
];

const yy_nxt: [i16; 11] = [   0,
         4,    5,    6,    8,    7,    9,    3,    9,    9,    9
];

const yy_chk: [i16; 11] = [   0,
         1,    1,    1,   11,   10,    3,    9,    9,    9,    9
];
/* footprint: 372 bytes */

/* m4 controls begin */
/* M4_MODE_HAS_BACKING_UP */
/* M4_MODE_NEED_YY_CP */
/* m4 controls end */

/* Character equivalence-class mapping */
const yy_ec: [u8; 256] = [ 0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    2,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1
];

/* Character meta-equivalence-class mappings */
const yy_meta: [u8; 4] = [ 0,
         1,    2,    3
];

/** The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
  */
macro_rules! REJECT {
    ( ($whatever:tt)* ) => { panic!("reject used but not detected"); }
}

macro_rules! yymore {
    ( ($whatever:tt)* ) => { panic("yymore used but not detected"); }
}

const MORE_ADJ: usize = 0;
const RESTORE_MORE_OFFSET: bool = false;

/* %% [3.0] static declarations conditional on mode switches go here */
/* First cut at a flex-based "wc" tool. */

const INITIAL: State = 0;

/** Number of entries by which start-condition stack grows. */
const START_STACK_INCR: usize = 25;

/* end tables serialization structures and prototypes */

// /** Setup the input buffer state to scan directly from a user-specified character buffer.
//  * @param base the character buffer
//  * @param size the size in bytes of the character buffer
//  * @param yyscanner The scanner object.
//  * @return the newly allocated buffer state object.
//  */
// YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
// {
// 	YY_BUFFER_STATE b;
//
// 	if ( size < 2 ||
// 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
// 	     base[size-1] != YY_END_OF_BUFFER_CHAR ) {
// 		/* They forgot to leave room for the EOB's. */
// 		return NULL;
// 	}
// 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
// 	if ( ! b ) {
// 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
// 	}
// 	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
// 	b->yy_buf_pos = b->yy_ch_buf = base;
// 	b->yy_is_our_buffer = 0;
// 	b->yy_input_file = NULL;
// 	b->yy_n_chars = b->yy_buf_size;
// 	b->yy_is_interactive = 0;
// 	b->yy_at_bol = 1;
// 	b->yy_fill_buffer = 0;
// 	b->yy_buffer_status = YY_BUFFER_NEW;
//
// 	yy_switch_to_buffer( b , yyscanner );
//
// 	return b;
// }
//
// /** Setup the input buffer state to scan a string. The next call to yylex() will
//  * scan from a @e copy of @a str.
//  * @param yystr a NUL-terminated string to scan
//  * @param yyscanner The scanner object.
//  * @return the newly allocated buffer state object.
//  * @note If you want to scan bytes that may contain NUL values, then use
//  *       yy_scan_bytes() instead.
//  */
// YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)
// {
//
// 	return yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);
// }
//
// /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
//  * scan from a @e copy of @a bytes.
//  * @param yybytes the byte buffer to scan
//  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
//  * @param yyscanner The scanner object.
//  * @return the newly allocated buffer state object.
//  */
// YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner) {
// 	YY_BUFFER_STATE b;
// 	char *buf;
// 	yy_size_t n;
// 	int i;
//
// 	/* Get memory for full buffer, including space for trailing EOB's. */
// 	n = (yy_size_t) (_yybytes_len + 2);
// 	buf = (char *) yyalloc( n , yyscanner );
// 	if ( ! buf ) {
// 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
// 	}
// 	for ( i = 0; i < _yybytes_len; ++i ) {
// 		buf[i] = yybytes[i];
// 	}
// 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
//
// 	b = yy_scan_buffer( buf, n , yyscanner);
// 	if ( ! b ) {
// 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
// 	}
// 	/* It's okay to grow etc. this buffer, and we should throw it
// 	 * away when we're done.
// 	 */
// 	b->yy_is_our_buffer = 1;
//
// 	return b;
// }

#[derive(Copy, Clone, Debug)]
pub struct FILE(*mut libc::FILE);

impl FILE {
    pub fn new(f: *mut libc::FILE) -> Self {
        FILE(f)
    }
}

impl PartialEq for FILE {
    fn eq(&self, other: &Self) -> bool {
        let a = &self.0 as *const _ as *mut libc::FILE;
        let b = &other.0 as *const _ as *mut libc::FILE;
        unsafe { libc::fileno(a) == libc::fileno(b) }
    }
}

impl Eq for FILE { }
